# Formura0 Temporary Grid Variable Benchmark Repository
This repository contains benchmarked programs in "Optimization of the code generated by a DSL for Stencil Computation using Temporary Grid Variables".

## Directory Structure
 - ./advect-rk2 : source code of lighter calculation TGVs make it worse.
 - ./result : The experiment result.
 - ./src : Source codes.
   - formura0 : Formura0 source code.
   - halide : Halide soruce code.
   - physis : Physis source code.

## detail of source codes.
### Formura0
fmr files are Formura0 source codes.  
The format of file name is:
>    %d-%s.fmr

 - %d is grid size.
 - %s is:
   - notgv : Not enabled TGV (forcely).
   - tgv : TGV-enabled.
   - tgv-if : TGV-enabled, but using conditional operator(if-expression).
   - noblocking-tgv : Not enabled blocking, but enabled TGV.
   - blocking%d-tgv : Block size is %d, TGV-enabled.

If compiling tgv files with `--notempgridvar` compiler option, present Formura0 compiler build without TGVs and generates the same output as notgv.  
To compare with Physis, we benchmarked tgv-if. It does conditional branch for boundary.

You only have to compile C source codes in `src/formura0/{float, double}`.
Set constants STEP and BENCH for simulation steps and whether output or benchmark.

### Halide
`halide%d.gen.cpp` are stencil codes, and `halide%d.cpp` are driver codes.

Set constants STEP and BENCH as well as Formura0 and COMPROOT which switches eqivalent to TGV or not.
You have to compile C source codes named `halide%d.gen.cpp`,
then execute generated executable files,
finally compile `halide%d.cpp`.  
For details: see `halide` rule in Makefile.

You need Halide's runtimes and headers.
You can download them from official Halide repository.

### Physis
`physis2?.%s.%d.c` are stencil codes users write, and `physis2?.%s.%d.ref.c` are generated codes by the Physis compiler.  
The difference of physis and physis2 is physis is not equivalent to TGV, but very natural description, physis2 is eqivalent to TGV.  

You have to compile C source codes named `physis2?.%s.%d.ref.cpp`.
You can switch benchmark or checking the output by command line option "bench" or "out".
For details: see physis rule in Makefile.


## How to make
You need to download Halide runtimes and headers from Halide official repository, and Physis from Physis official repository.  
Then rewrite constants `halideDir`, `physisRuntimeDir`, and `physisIncludeDir` in Makefile.

Then run `make all`.

You can `./runBench.sh`.

## Benchmark
### The Environment
> OS : Debian Buster  
> CPU : Ryzen 3700X  
> On Hyper-V (Windows 11 Pro)  
> Compiler Option : -O3 -march=native  
> Compiler : gcc  

### The Main Result
We benchmarked the diffusion equation with the 4-stage Runge-Kutta method.
#### float
##### size: 100×100
| Name of Source Code File | Compiler Option(-D) | DSL Name | Remembering Temporary Variables? | Boundary method | Elasped Time[sec] |
| :--: | :--: | :--: | :--: | :--: | :--: |
| formura0/float/100-notgv.c | -D STEP=1000 -D BENCH=1 | Formura0 | No | Dedicated Loop | 317 |
| formura0/float/100-tgv.c | -D STEP=1000 -D BENCH=1 | Formura0 | Yes | Dedicated Loop | 33 |
| formura0/float/100-tgv-if.c | -D STEP=1000 -D BENCH=1 | Formura0 | Yes | if branch | 92 |
| halide/halide100.c | -D STEP=1000 -D BENCH=1 | Halide | No | ? | 484 |
| halide/halide100.c | -D STEP=1000 -D BENCH=1 -D COMPROOT=1 | Halide | Yes | ? | 50 |
| physis/physis.float.100.ref.c |  | Physis | No | if branch | 369 |
| physis/physis2.float.100.ref.c |  | Physis | Yes | if branch | 127 |

##### size: 1000×1000
| Name of Source Code File | Compiler Option(-D) | DSL Name | Remembering Temporary Variables? | Block size | Boundary method | Elasped Time[sec] |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| formura0/float/1000-notgv.c | -D STEP=100 -D BENCH=1 | Formura0 | No | N/A | Dedicated Loop | 416 |
| formura0/float/1000-noblocking-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | N/A | if branch | 47 |
| formura0/float/1000-noblocking-tgv-if.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | N/A | if branch | 121 |
| formura0/float/1000-blocking100-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 100 | if branch | 54 |
| formura0/float/1000-blocking125-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 125 | if branch | 52 |
| formura0/float/1000-blocking250-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 250 | if branch | 49 |
| formura0/float/1000-blocking500-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 500 | if branch | 46 |
| halide/halide1000.c | -D STEP=100 -D BENCH=1 | Halide | No | N/A | ? | 186 |
| halide/halide1000.c | -D STEP=100 -D BENCH=1 -D COMPROOT=1 | Halide | Yes | N/A | ? | 48 |
| physis/physis.float.1000.ref.c |  | Physis | No | N/A | if branch | 474 |
| physis/physis2.float.1000.ref.c |  | Physis | Yes | N/A | if branch | 158 |

#### double
##### size: 100×100
| Name of Source Code File | Compiler Option(-D) | DSL Name | Remembering Temporary Variables? | Boundary method | Elasped Time[sec] |
| :--: | :--: | :--: | :--: | :--: | :--: |
| formura0/double/100-notgv.c | -D STEP=1000 -D BENCH=1 | Formura0 | No | Dedicated Loop | 323 |
| formura0/double/100-tgv.c | -D STEP=1000 -D BENCH=1 | Formura0 | Yes | Dedicated Loop | 49 |
| formura0/double/100-tgv-if.c | -D STEP=1000 -D BENCH=1 | Formura0 | Yes | if branch | 82 |
| physis/physis.double.100.ref.c |  | Physis | No | if branch | 383 |
| physis/physis2.double.100.ref.c |  | Physis | Yes | if branch | 129 |

##### size: 1000×1000
| Name of Source Code File | Compiler Option(-D) | DSL Name | Remembering Temporary Variables? | Block size | Boundary method | Elasped Time[sec] |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| formura0/float/1000-notgv.c | -D STEP=100 -D BENCH=1 | Formura0 | No | N/A | Dedicated Loop | 393 |
| formura0/float/1000-noblocking-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | N/A | if branch | 72 |
| formura0/float/1000-noblocking-tgv-if.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | N/A | if branch | 97 |
| formura0/float/1000-blocking100-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 100 | if branch | 69 |
| formura0/float/1000-blocking125-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 125 | if branch | 65 |
| formura0/float/1000-blocking250-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 250 | if branch | 68 |
| formura0/float/1000-blocking500-tgv.c | -D STEP=100 -D BENCH=1 | Formura0 | Yes | 500 | if branch | 66 |
| physis/physis.double.1000.ref.c |  | Physis | No | N/A | if branch | 383 |
| physis/physis2.double.1000.ref.c |  | Physis | Yes | N/A | if branch | 154 |


### The Sub Result
We benchmarked the advection equation with the 2-stage Runge-Kutta method to show that sometime TGV may make worse results.

TGV : 27  
no TGV : 17
